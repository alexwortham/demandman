\documentclass[12pt,letterpaper]{article}
\usepackage[ampersand]{easylist}
\usepackage[margin=1in]{geometry}
\usepackage{requirements}
\usepackage{float}
\usepackage{amsmath}
\usepackage{graphicx}
\bibliography{Bibliography.bib}
%% @DocumentRequirement (1.1,"Title")
\title{Progress Report}
%% @DocumentRequirement (1.3,"Team #")
\team{1}
%% @DocumentRequirement (1.4,"Team Members")
\author{Alex Chaloux, Alex Wortham, Asanga Bandara, Doug Bouler, Chauncey Meade}
%% @DocumentRequirement (1.5,"Customer")
\customer{EPRI}

\begin{document}

%% @DocumentRequirement (1,"Title Page")
%% @DocumentRequirement (1.2,"Date")
\reqstitlepage

\tableofcontents
\clearpage

%\setstretch{1}
%% @DocumentRequirement (2,"Introduction")
\section{Introduction}

Within the past several decades, the information revolution has brought
incredible new technologies and devices to the hands of many Americans. In
addition, the power grid is currently undergoing major updates as renewable
energy sources are being implemented and older fossil fuel sources are being
phased out. Due to the continually increasing energy requirements, it is also
very important that better management of electrical demand on the grid be
implemented. Whereas energy (kWh) is measured over a period of time, electrical
demand (kW) is an instantaneous measurement of power usage at a point in time.
Currently utility companies have no way to control the electrical demand, instead being
forced to react to it as it comes. This comes at a great cost to utility
companies, and this cost is beginning to be passed off onto their customers as
demand charges. Unfortunately, the way in which demand charges are calculated
and how they differ from normal power bills can be difficult to understand for
the average user. This is where our project seeks to help. By monitoring
electrical usage of the major appliances in a user's home, we hope to give the
user a simple way to monitor the cost of their electrical demand for the month.
Given the time constraints on the project, we will be simulating AC loads on
custom built DC circuits to reduce design complexity.

We have made significant progress on our project since the start of the
semester. After researching similar products on the market, we began creating
and testing different designs. We have reached a design we believe will be very
effective and have begun prototyping the full system. The rest of this report
goes in depth on our research, design, and current progress on prototypes.


\clearpage
%% @DocumentRequirement (3,"Investigation / Research of Solution(s)")
\section{Research of Solutions}
Before we began designing we performed thorough market research, and found
several products that are already available. Though these products cannot
directly control the appliance, they can indicate the power usage to the user
through various means. See Table 
\ref{table:product_comparison} below for more information on a few of the
products we researched.

\begin{table}[h]
    \centering 
    \includegraphics[clip=true,trim=.75in
    1.5in .75in 1.25in,width=.86\textwidth]{images/Compare_Products_v2.pdf}
    \caption{Product Comparison}
    \label{table:product_comparison}
\end{table}


\clearpage
%% @DocumentRequirement (4,"Prototyping of Solution")
\section{Prototyping of Solution}

Having selected the BeagleBone Black (BBB) as our microcontroller, we began work
prototyping both hardware and software immediately. The discussion of our
prototyping is broken down into two sections, one for hardware and one for
software. 

\subsection{Hardware Solution}

Our design features two main hardware components; a demand control and
monitoring component along with a simulation component. To simplify our
simulation component's circuits, we will be simulating alternating current (AC)
appliance loads on direct current (DC). These circuits are designed to provide
loads which are both measurable by our selected current sensor, and measurable
to the naked eye by status LEDs (light emitting diodes). The demand control and
monitoring component will measure the loads generated by the simulation circuits
as well as control relays which can enable or disable each simulation circuit. 
Below is a high level diagram of our product.


\begin{figure}[!ht]
	\centering
	\includegraphics[clip=true,trim=.25in
	3.15in .25in .55in,width=.75\textwidth]{images/Project_Plan-5.pdf}
	\caption{Product Diagram}
	\label{figure:diagram}
\end{figure}

\clearpage
\subsubsection{I$^2$C Load Simulation Circuit}

In order to effectively demonstrate our product, we wanted to create a
demonstration using ``dummy loads'', digitally-controlled simulated loads. Based
on the appliance usage data with the time, we are going to demonstrate how much
current draw on each appliance when it's operating. Due to the typical
waveforms associated with household appliances we decided that each load should have a
designated number of digital control levels. For now, we have chosen that each
load can be accurately represented by six different levels. This technique
requires at least six pins on the microprocessor per load. Alternatively, to
conserve pins on the microprocessor, we could communicate with the
microprocessor through an I$^2$C bus. In this case, fewer lines are connected
to the microprocessor pins and each load can be controlled by a string of bits. We
selected the PCF8574 I$^2$C 8-bit I/O port expander.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{images/I2C_PCF8574.pdf}
	\caption{I$^2$C load simulation circuit}
	\label{figure:i2c_circuit}
\end{figure}

The PCF8574 has a two-wire communication bus that the microprocessor monitors
for each PCF8574 device. Up to eight lines can be connected to the PCF8574
parallel input/output (I/O) port (P port). Furthermore, the PCF8574 has low
current consumption and includes latched outputs with high current drive
capability for directly driving LEDs and other loads. The I$^2$C bus consists
of two active wires and a ground connection. The active wires are the bidirectional
serial data (SDA) line and the bidirectional serial clock (SCL) line. By using
the PCF8574, our circuit can be greatly simplified as compared to complex
glue-logic interface circuitry. This I$^2$C will also allow us to reduce the
total PCB area used and to improve system reliability.

\clearpage
\subsubsection{Analog Current Monitoring Circuit}

Current monitoring is the main intention behind the hardware portion of the
project. Since we are using a DC current demonstration to show the appliance
usage, we are going to use a DC current monitoring circuit for this design.
Future products would instead use an AC current monitor in the place of a DC
current transformer to measure the current flow through the device. In both
cases, analog to digital conversion is required to read the current flow. The
dummy loads that represent the appliance will draw current from the circuit;
this current will be measured using a current sensor attached to the circuit.
For this purpose we have selected the ACS712 Hall effect-based linear current
sensor.
   
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{images/Current_Sensor.pdf}
	\caption{Analog Current Monitoring Circuit}
	\label{figure:analog_circuit}
\end{figure}

This device consists of a precise, low-offset, linear Hall sensor circuit with a
copper conduction path located near the surface of the die. Applied current
flowing through this copper conduction path generates a magnetic field which is
sensed by the integrated Hall IC and converted into a proportional voltage. This
analog voltage will compare this current to the proportional current flow
through the circuit using the BBB. However, the BBB analog input has a maximum
voltage rating of 1.8V. Due to this hardware limitation, we will have to use a
voltage divider circuit and protection circuit before allowing the current
sensor analog input signal into the BBB. The current monitoring circuit diagram
shows how we are going to monitor the current flow using the ACS712 current
sensor along with overvoltage protection.

\clearpage
\subsubsection{GPIO Relay Control Circuit}

In this part of the circuit we are going to control the simulated appliance by
using a relay module. In order for two circuits to be operating at the same
time, we must devise an algorithm by which to control the availability of each
device to the user. This control algorithm allows us to control the appliances'
ON/OFF statuses and availability.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{images/Relay_Controlling.pdf}
	\caption{GPIO Relay Control Circuit}
	\label{figure:gpio_circuit}
\end{figure}

To control the relay module we selected the ULN2003B IC.  The ULN2803A device is
a high-voltage, high-current Darlington transistor array. The device consists of
eight NPN Darlington pairs that feature high-voltage outputs with common-cathode
clamp diodes for switching inductive loads.  The very high $\beta$ (current
amplification coefficient) allows for a high output current drive with a very
low input current, allowing us to operate with low GPIO voltages.

\subsection{Software Solution}

The software prototypes were split into the following categories.

\begin{itemize}
  \item A PHP extension written in C to control these I/Os.
  \begin{itemize}
    \item I$^2$C
    \item General purpose input output (GPIO)
    \item Analog input
  \end{itemize}
  \item Simple procedural PHP scripts to test the PHP extension.
  \item Object-Oriented (OO) PHP classes to control the I/Os.
  \item Simple prodecural PHP script to playback load curve data to I$^2$C.
  \item OO PHP Classes for simultaneous playback of up to 4 simulations.
  \item A Model-View-Controller style user interface created with Laravel.
  \item Loosely coupled OO interfaces for driving the control management
  component.
  \item A proposed API framework for demand--aware smart appliances.
\end{itemize}

Critical to our vision of a software solution written exclusively in one
programming language was the development of the PHP extension for controlling
the I/Os. This prototype came to fruition quickly by modifying existing open
source software to run in a PHP extension. Once complete, its functionality was
verified by some simple procedural PHP test scripts run with our prototype
circuits connected to the BBB. When these tests were passing, development moved
on to the object-oriented (OO) PHP classes for ultimate use in the final
product.

The simulation software is one of the major components in our project, and we
began prototyping on it quickly after the I/O concerns were taken care of. 
First a procedural PHP script was written to playback load curve data in Comma
Separated Value (CSV) files, and it was later followed by an OO version which
could playback load curve data stored in a Structured Query Language (SQL)
database. Both of these prototype solutions could only manage simulation of a
single load curve so we moved our focus to being able to simulate up to 4 load
curves simultaneously. Though it was an interesting challenge coordinating
communincation between distinct PHP processes, a solution was realized that led
to the development of our proposed API framework.

Our proposed Application Programmer Interface (API) framework was born out of a
necessity for our two BeagleBones to communicate over a network. At first the
best solution appeared to be a web service API using JavaScript Object Notation
(JSON) payloads. We ultimately selected an open source software called Redis
for simpler implementation and other reasons further discussed in the next
section. Critical to a successful implementation of any API is a loosely
coupled interface driven design; a pattern which we have adopted and applied to
our prototype API.

One of our main goals is to create a product that presents a user's electrical
demand in an easy to understand format. To do so we needed to choose a medium
for the interface that is easily accessible on a wide variety of devices. We
concluded that a web based interface is the best medium to accomplish our goals.
To eliminate the error prone, time consuming process of writing a web
application from scratch we chose the Laravel framework as a base for our user
interface and API. 

%% @DocumentRequirement (5,"Evaluation of Solution")
\section{Evaluation of Solution}

Many elements of this project were designed in advance for us. After meeting
with our customer for the first time, we realized that he already had a detailed
idea of an end goal for this project. He knew exactly what he wanted from the
project and he even had an idea as to how he preferred that we demonstrate our
solution. Even though we were not provided an exhaustive list of requirements,
the customer's clear goals allowed us to refine our thinking into a much more
focused direction. The ultimate goal of this project is to prove to the customer
that we can control a group of four loads while keeping the instantaneous demand
at a minimum. Any solution that we choose must first meet this requirement.

After evaluating this project, we knew that we needed a controller, a current
sensing mechanism, simulated loads, and a user interface. There are hundreds of
controllers capable of controlling four DC loads, thousands of current sensing
techniques, and millions of potential combinations. Using the BeagleBone Black
(BBB) microcontroller gave us supreme versatility when considering the
sensitive Analog-to-digital converter (ADC) for the feedback loop and the
numerous I/O for both the control system and the simulation system. The
BBB is also adept with wireless communication, which we felt was
extremely important for our final product and demonstration design.

We have decided to use a simple, commercial current sensor because of the low
cost and simplicity of integration into the circuit. For this project,
simplicity is necessary to properly demonstrate a proof of concept solution.
Therefore, using a simplistic current sensor with a biasing and feedback network
will allow us to minimize potential hardware issues and increase overall
consistency of the system. Our sensor was also chosen based on the sensitivity
of the device to changes in current. In order to provide detailed information to
our customer regarding their demand and power usage, we need to incorporate an
accurate device with sensitivity suitable for monitoring small DC loads. We
believe that the current sensor we chose does an adequate job, but we must now
model the loads around the sensitivity of our sensor. In reality, many household
appliances draw amps if not tens of amps. In our application, we would most
likely be measuring hundreds of milliamps. This may force us to choose a
different device in the future once we realize the full extent of our simulated
load design.

Though we have not begun to integrate the user interface, we believe that this
solution provides cohesion to our system. Creating an OS-specific app adds
unnecessary complexity for both our team and the user; by choosing to use a
web-based application, users can monitor their monthly demand and demand charges
through both browsers and simple smartphone applications. A few of our group
members have considerable experience designing web based applications and so
this decision was much more in our realm of expertise.

The BBB's unique microcontroller language, Bonescript, is the simplest
way to access the BBB's I/Os but is not suitable for creating a web based user
interface. PHP is a very versitile, high performance, and non resource
intensive language initially created for the purpose of developing 
dynamic HTTP web sites, making it an excellent choice for creating our user
interface. We considered at first using a combination of PHP and Bonescript to
implement our software, but decided it would be easier to develop and maintain
the software if it was all written in a single language.

Interestingly, at the time this idea was conceived there was no way to directly
access the BBB's I/O's using PHP. The PHP interpreter is written in C, as is
the Python interpreter. After some examination we decided it would be trivial
to port existing open source code for accessing the BBB's I/Os with Python to
PHP. After some experimenting this proved to be true, and we pushed forward to
develop an extension for PHP that allows us to directly access the BBB's I/Os.
With our new PHP extension in hand, our goal to develop a code base exclusively
in a single language is now possible.

A properly developed web application requires many careful
considerations about software design. The Model-View-Controller (MVC) paradigm
takes all of these considerations into account and provides a simple, clear cut
structure for implementing a web application. Of the many MVC driven PHP
frameworks we researched the Laravel framework was the strongest proponent of
loosely coupled software design making it the best fit for both our user
interface and API.

Nearly every programming language has libraries that allow
communication through HTTP and JSON, allowing manufacturers to write software
for communication with our API in any language they want. Though the
combination of the Hypertext Transfer Protocol (HTTP) and JSON is relatively
simple and lightweight, there still is a lot of protocol overhead involved. 
Redis uses a much more terse network protocol for passing messages between
publishers and subscribers, thereby reducing the overhead compared to the
HTTP/JSON solution. Better still, libraries for communicating with Redis exist
in just as many languages as HTTP and JSON which affords consumers of our API
the same luxury of choice in writing their client software. 

%s% @DocumentRequirement (6,"Summary")
\section{Summary}

Our ultimate goal is to assist consumers with monitoring and controlling the
instantaneous electrical demand of their household. This is necessary due to the
shifting of pricing models of utility companies, which is coming about as a
result of the high cost of meeting an ever-rising demand during peak usage
hours. We believe that our solution's design will prove to our customer that
this is possible and economically feasible. Our solution will also provide our
customer with a means to demonstrate this to his peers and investors in the
power industry.

We have accomplished a considerable amount since the start of this semester. We
have sculpted a design that will accomplish our goals, and we have implemented
the core pieces of both the hardware and software that will be necessary for our
project. We have prototyped our solution for one load, and we are nearing
completion of the design of the hardware components and the software driver of
our demonstration.

Next, we will need to expand our prototypes to include all four required loads.
This will involve duplication of electrical components, as well as strenuous
testing of the software drivers. We will also need to combine our components
into a presentable demonstration. To do this, we will need to finish designing
our user interface, and then implement it.

Upon completion of our project, we will have created a demonstration that will
prove the practicality of monitoring and controlling residential electrical
loads without the need for devices that can intercommunicate. Using the concepts
that our solution will prove, consumers will be able to reduce their power bill
without replacing expensive appliances in their household. This provides
economic viability to our solution, which will enable our customers to
accomplish their goals.


\clearpage
%% @DocumentRequirement (7,"Customer's Agreement")
\clearpage
\section{Customer Approval}


%% @DocumentRequirement (7.1,"A page dated and signed by the customer
%% 									approving your report")



Team,

I am okay with what you have submitted.  I have a few minor corrections in the file attached.  I am not an expert on the h/w side, especially with the details you have provided.  I will rely on your understanding and experience with that section.
 
Learning moment –
As a general rule, always leave time for unforeseen circumstances.  I am traveling (so is Ben) and have no access to printer / scanner so I cannot sign the document.  Please consider this email as approval.  
 
 ~\

Thanks,

Harshal
 
 ~\
 
Harshal Upadhye

Desk : 865-218-8135

Cell : 650-714-3758

\end{document}